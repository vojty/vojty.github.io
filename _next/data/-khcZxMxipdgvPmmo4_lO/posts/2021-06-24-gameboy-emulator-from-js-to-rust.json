{"pageProps":{"source":{"compiledSource":"var d=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(t,a,n)=>a in t?d(t,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[a]=n,e=(t,a)=>{for(var n in a||(a={}))o.call(a,n)&&l(t,n,a[n]);if(r)for(var n of r(a))s.call(a,n)&&l(t,n,a[n]);return t},h=(t,a)=>m(t,c(a));var p=(t,a)=>{var n={};for(var i in t)o.call(t,i)&&a.indexOf(i)<0&&(n[i]=t[i]);if(t!=null&&r)for(var i of r(t))a.indexOf(i)<0&&s.call(t,i)&&(n[i]=t[i]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var i=n,{components:t}=i,a=p(i,[\"components\"]);return mdx(MDXLayout,h(e(e({},layoutProps),a),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Some of you might know that I've been on a journey to implement the GameBoy\nemulator.`),mdx(\"p\",null,\"I've decided to write down a few thoughts I've come into during the development.\"),mdx(\"h2\",e({},{id:\"the-origins\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#the-origins\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"The origins\"),mdx(\"p\",null,`I think I started this project in the summer of 2019. I always wanted to have a\nside project where I can polish things infinitely and try new technologies.\nActually, the original idea was to create a PS1 emulator, but I quickly realized\nthat emulating PS1 is `,mdx(\"strong\",{parentName:\"p\"},\"much harder\"),` than GB (and I didn't have any experience\nin emulating systems anyway).`),mdx(\"p\",null,`I didn't want to spend a lot of time learning a new programming language, so I\ndecided to use TypeScript which I had been using daily.`),mdx(\"p\",null,\"Timeline\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"2019 Fall - start\"),mdx(\"li\",{parentName:\"ul\"},\"2019 Winter - the first successful boot with scrolling Nintendo logo\"),mdx(\"li\",{parentName:\"ul\"},\"2020 March - working Dr. Mario and passing some integration tests\"),mdx(\"li\",{parentName:\"ul\"},\"2020 May - major refactor and made the CPU cycle-accurate\"),mdx(\"li\",{parentName:\"ul\"},\"2020 Summer - added support for general MBCs, many games was playable by then\"),mdx(\"li\",{parentName:\"ul\"},`2020 Fall - finally created scripts for automated testing, improved PPU's\naccuracy (added FIFO for background tiles and improved timing of some STAT\ninterrupts)`)),mdx(\"p\",null,`At the end of 2020, I started working on APU (audio processing unit). By then\nthe code was becoming slightly messy because I was discovering new things on the\nfly and had to refactor very often.`),mdx(\"h2\",e({},{id:\"transition-to-rust\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#transition-to-rust\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Transition to Rust\"),mdx(\"h3\",e({},{id:\"why\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#why\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Why\"),mdx(\"p\",null,`Fast forward to the beginning of 2021, I decided to completely rewrite the\nemulator to Rust. These were the major impulses:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`Rust can be compiled to WASM - I wanted to preserve the idea of Gameboy in the\nbrowser`),mdx(\"li\",{parentName:\"ul\"},`I was generally interested in Rust - I watched few Rust presentations, did\nsome exercises during the fall of 2020 and was ready to write something bigger`),mdx(\"li\",{parentName:\"ul\"},`I needed to build advanced debugging tools and visualize the internals in the\nreal-time. I was looking for something like\n`,mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/ocornut/imgui\"}),\"Dear ImGui\"),` for the browser, but I didn't\nfind anything quite usable (although there are JS bindings for Dear ImGui, the\nlibrary is missing an ES build & the dist version is polluted with SystemJS\nand the maintainer wants to keep it that way apparently...). Luckily I found\n`,mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/emilk/egui\"}),\"egui\")),mdx(\"li\",{parentName:\"ul\"},`Performance - During the development, the CPU usage in the browser went from\naround 20-30% to 80%`)),mdx(\"h3\",e({},{id:\"performance-issues\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#performance-issues\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Performance issues\"),mdx(\"p\",null,\"Let's do some basic calculation first:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`GameBoy's CPU runs at 4 194 304 Hz, the FPS is 59.7275 Hz\n->\n4 194 304 / 59.7275\\xA0=\\xA070 224 cycles per frame\n`)),mdx(\"p\",null,\"The alternative calculation:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`One scanline takes 456 cycles\nThere are 144 visible lines + 10 lines during V-blank\n->\n456 * (144 + 10) = 70 224 cycles per frame\n`)),mdx(\"p\",null,`Given the fact that one instruction takes 1-4 cycles to execute, you need to\nprocess more than `,mdx(\"strong\",{parentName:\"p\"},\"17 000 instructions per every frame\"),`. That's quite a lot so\nany \"not so optimal\" code in some critical execution path can affect your\nperformance greatly.`),mdx(\"p\",null,`This makes your debugging quite hard as well. You usually want to see what\nhappened during the code execution and print (almost) every step, but putting\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"console.log\"),` after every instruction is not really an option, because the\nbrowser will immediately freeze.`),mdx(\"p\",null,`Although it's definitely doable to write somehow performant GB emulator only in\nJavascript, I didn't care about the performance (we are used to the fact Chrome\neats all the RAM, right?) until it was kinda late and I didn't want to optimize\nmy messy code anyway.`),mdx(\"h3\",e({},{id:\"architecture-change\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#architecture-change\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Architecture change\"),mdx(\"p\",null,`I decided to split the project into multiple parts - the GB core and the\nfrontends. The simplified public API of the core is just 2 functions\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"run_frame()\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"get_screen_buffer()\"),`. The frontend can be anything - it just\nneeds to execute `,mdx(\"inlineCode\",{parentName:\"p\"},\"run_frame()\"),` and draw the screen buffer around 60 times per\nsecond. With this approach, I was able to develop the emulator with SDL2 on my\ncomputer and convert it to a web version using\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/rustwasm/wasm-bindgen\"}),\"wasm-bindgen\"),` afterward. Finally, the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"egui\"),` library (which can target WASM with WebGL) gave me the power to build\ncross-platform debugging tools. Suddenly I was able to write a simple and\nreal-time disassembler with no performance issues (the GUI web app is very\nperformant since it's WebGL).`),mdx(\"h3\",e({},{id:\"performance-concerns\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#performance-concerns\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Performance concerns\"),mdx(\"p\",null,`I like the concept of immutability and it's also quite popular or even required\nwhen developing frontend with React. Usually, you just create or clone objects\nand arrays (although many times they are just shallow copies) as you need\nwithout any performance concerns.`),mdx(\"p\",null,`But writing an emulator this way is a terrible idea. One thing you want to avoid\nas much as possible is dynamic memory allocation. Almost everything in the\nGameBoy development has a fixed size so you can allocate the space upfront.`),mdx(\"p\",null,`Once, I hacked something very quickly and made a silly mistake. I used\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"std::collections::HashMap\"),` when I tried to store some information for every\nrendered pixel in the line like this\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"hashMap.insert(pixel_x, (color_number, priority))\"),`. When I checked the emulator\nin the browser after some time I noticed that the performance went somehow from\n~30% of CPU to almost 85%. Fortunately, I was able to trace this problem with\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/flamegraph-rs/flamegraph\"}),\"flamegraph\"),` very quickly. Those\nextra allocations more than doubled the overall performance. Using different\ndata structure fixed the problem.`),mdx(\"h2\",e({},{id:\"final-thoughts\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#final-thoughts\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Final thoughts\"),mdx(\"p\",null,`Sometimes it's better to start from scratch than trying to rewrite existing\ncode. The rewrite took me around two weeks and it was a pretty straightforward\nprocess. Few times I got stuck when I tried to figure out \"how to do X in Rust\"\nbut that's how you learn a new language I guess. Changing the technology helped\nme to build things I wouldn't be able to do with pure TS/JS or they would be too\nslow.`),mdx(\"p\",null,\"The demo of my emulator can be found here \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://vojty.github.io/feather-gb\"}),\"https://vojty.github.io/feather-gb\")))}MDXContent.isMDXComponent=!0;\n","scope":{"title":"GameBoy Emulation - From Typescript to Rust","description":"Few thoughts on switching from Typescript to Rust during the GameBoy emulator development","date":"2021-06-14"}},"frontMatter":{"title":"GameBoy Emulation - From Typescript to Rust","description":"Few thoughts on switching from Typescript to Rust during the GameBoy emulator development","date":"2021-06-14"}},"__N_SSG":true}