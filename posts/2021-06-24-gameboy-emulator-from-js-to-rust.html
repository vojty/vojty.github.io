<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try{var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem("theme");if(e){d.add(e)}else{d.add('dark');}}catch(t){}}();</script><title>GameBoy Emulation - From Typescript to Rust - Tomáš Vojtášek</title><meta content="Few thoughts on switching from Typescript to Rust during the GameBoy emulator development" name="description"/><meta property="og:type" content="article"/><meta property="og:site_name" content="Personal blog by Tomáš Vojtášek"/><meta property="og:description" content="Few thoughts on switching from Typescript to Rust during the GameBoy emulator development"/><meta property="og:title" content="GameBoy Emulation - From Typescript to Rust - Tomáš Vojtášek"/><meta property="og:image"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@TomasVojtasek"/><meta name="twitter:title" content="GameBoy Emulation - From Typescript to Rust - Tomáš Vojtášek"/><meta name="twitter:description" content="Few thoughts on switching from Typescript to Rust during the GameBoy emulator development"/><meta name="twitter:image"/><meta property="article:published_time" content="2021-06-14"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/85bc52513bb2f5913ccf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/85bc52513bb2f5913ccf.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-61095c13c5984b221292.js" defer=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" defer=""></script><script src="/_next/static/chunks/main-588261c74baf7142d208.js" defer=""></script><script src="/_next/static/chunks/pages/_app-30dfa85e84781b24d169.js" defer=""></script><script src="/_next/static/chunks/635-3524f47544f49539b254.js" defer=""></script><script src="/_next/static/chunks/522-2597210efd9529a81949.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-d5970f37e1ad941173a7.js" defer=""></script><script src="/_next/static/HWNRKxqCMGzF0_X3yiJQA/_buildManifest.js" defer=""></script><script src="/_next/static/HWNRKxqCMGzF0_X3yiJQA/_ssgManifest.js" defer=""></script></head><body class="bg-white dark:bg-black text-gray-900 dark:text-white"><div id="__next"><header><div class="max-w-5xl px-8 mx-auto"><div class="flex items-center py-6"><img class="mr-4" src="/_next/static/image/public/feather.17827f3d2a1b3c4a3b3aae980cb0f81b.svg" height="20" width="20"/><nav><a class="text-gray-900 dark:text-white pr-6 py-4" href="/">Blog</a><a class="text-gray-900 dark:text-white pr-6 py-4" href="/about">About</a></nav><div class="ml-auto"></div></div></div></header><main><div class="max-w-5xl px-8 py-4 mx-auto"><article><h1 class="mb-3 text-gray-900 dark:text-white">GameBoy Emulation - From Typescript to Rust</h1><p class="mb-10 text-sm text-gray-500 dark:text-gray-400">June 14, 2021</p><div class="prose dark:prose-dark"><p>Some of you might know that I&#x27;ve been on a journey to implement the GameBoy
emulator.</p><p>I&#x27;ve decided to write down a few thoughts I&#x27;ve come into during the development.</p><h2 id="the-origins"><a aria-hidden="true" tabindex="-1" href="#the-origins"><span class="icon icon-link"></span></a>The origins</h2><p>I think I started this project in the summer of 2019. I always wanted to have a
side project where I can polish things infinitely and try new technologies.
Actually, the original idea was to create a PS1 emulator, but I quickly realized
that emulating PS1 is <strong>much harder</strong> than GB (and I didn&#x27;t have any experience
in emulating systems anyway).</p><p>I didn&#x27;t want to spend a lot of time learning a new programming language, so I
decided to use TypeScript which I had been using daily.</p><p>Timeline</p><ul><li>2019 Fall - start</li><li>2019 Winter - the first successful boot with scrolling Nintendo logo</li><li>2020 March - working Dr. Mario and passing some integration tests</li><li>2020 May - major refactor and made the CPU cycle-accurate</li><li>2020 Summer - added support for general MBCs, many games was playable by then</li><li>2020 Fall - finally created scripts for automated testing, improved PPU&#x27;s
accuracy (added FIFO for background tiles and improved timing of some STAT
interrupts)</li></ul><p>At the end of 2020, I started working on APU (audio processing unit). By then
the code was becoming slightly messy because I was discovering new things on the
fly and had to refactor very often.</p><h2 id="transition-to-rust"><a aria-hidden="true" tabindex="-1" href="#transition-to-rust"><span class="icon icon-link"></span></a>Transition to Rust</h2><h3 id="why"><a aria-hidden="true" tabindex="-1" href="#why"><span class="icon icon-link"></span></a>Why</h3><p>Fast forward to the beginning of 2021, I decided to completely rewrite the
emulator to Rust. These were the major impulses:</p><ul><li>Rust can be compiled to WASM - I wanted to preserve the idea of Gameboy in the
browser</li><li>I was generally interested in Rust - I watched few Rust presentations, did
some exercises during the fall of 2020 and was ready to write something bigger</li><li>I needed to build advanced debugging tools and visualize the internals in the
real-time. I was looking for something like
<a href="https://github.com/ocornut/imgui">Dear ImGui</a> for the browser, but I didn&#x27;t
find anything quite usable (although there are JS bindings for Dear ImGui, the
library is missing an ES build &amp; the dist version is polluted with SystemJS
and the maintainer wants to keep it that way apparently...). Luckily I found
<a href="https://github.com/emilk/egui">egui</a></li><li>Performance - During the development, the CPU usage in the browser went from
around 20-30% to 80%</li></ul><h3 id="performance-issues"><a aria-hidden="true" tabindex="-1" href="#performance-issues"><span class="icon icon-link"></span></a>Performance issues</h3><p>Let&#x27;s do some basic calculation first:</p><pre><code>GameBoy&#x27;s CPU runs at 4 194 304 Hz, the FPS is 59.7275 Hz
-&gt;
4 194 304 / 59.7275 = 70 224 cycles per frame
</code></pre><p>The alternative calculation:</p><pre><code>One scanline takes 456 cycles
There are 144 visible lines + 10 lines during V-blank
-&gt;
456 * (144 + 10) = 70 224 cycles per frame
</code></pre><p>Given the fact that one instruction takes 1-4 cycles to execute, you need to
process more than <strong>17 000 instructions per every frame</strong>. That&#x27;s quite a lot so
any &quot;not so optimal&quot; code in some critical execution path can affect your
performance greatly.</p><p>This makes your debugging quite hard as well. You usually want to see what
happened during the code execution and print (almost) every step, but putting
<code>console.log</code> after every instruction is not really an option, because the
browser will immediately freeze.</p><p>Although it&#x27;s definitely doable to write somehow performant GB emulator only in
Javascript, I didn&#x27;t care about the performance (we are used to the fact Chrome
eats all the RAM, right?) until it was kinda late and I didn&#x27;t want to optimize
my messy code anyway.</p><h3 id="architecture-change"><a aria-hidden="true" tabindex="-1" href="#architecture-change"><span class="icon icon-link"></span></a>Architecture change</h3><p>I decided to split the project into multiple parts - the GB core and the
frontends. The simplified public API of the core is just 2 functions
<code>run_frame()</code> and <code>get_screen_buffer()</code>. The frontend can be anything - it just
needs to execute <code>run_frame()</code> and draw the screen buffer around 60 times per
second. With this approach, I was able to develop the emulator with SDL2 on my
computer and convert it to a web version using
<a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> afterward. Finally, the
<code>egui</code> library (which can target WASM with WebGL) gave me the power to build
cross-platform debugging tools. Suddenly I was able to write a simple and
real-time disassembler with no performance issues (the GUI web app is very
performant since it&#x27;s WebGL).</p><h3 id="performance-concerns"><a aria-hidden="true" tabindex="-1" href="#performance-concerns"><span class="icon icon-link"></span></a>Performance concerns</h3><p>I like the concept of immutability and it&#x27;s also quite popular or even required
when developing frontend with React. Usually, you just create or clone objects
and arrays (although many times they are just shallow copies) as you need
without any performance concerns.</p><p>But writing an emulator this way is a terrible idea. One thing you want to avoid
as much as possible is dynamic memory allocation. Almost everything in the
GameBoy development has a fixed size so you can allocate the space upfront.</p><p>Once, I hacked something very quickly and made a silly mistake. I used
<code>std::collections::HashMap</code> when I tried to store some information for every
rendered pixel in the line like this
<code>hashMap.insert(pixel_x, (color_number, priority))</code>. When I checked the emulator
in the browser after some time I noticed that the performance went somehow from
~30% of CPU to almost 85%. Fortunately, I was able to trace this problem with
<a href="https://github.com/flamegraph-rs/flamegraph">flamegraph</a> very quickly. Those
extra allocations more than doubled the overall performance. Using different
data structure fixed the problem.</p><h2 id="final-thoughts"><a aria-hidden="true" tabindex="-1" href="#final-thoughts"><span class="icon icon-link"></span></a>Final thoughts</h2><p>Sometimes it&#x27;s better to start from scratch than trying to rewrite existing
code. The rewrite took me around two weeks and it was a pretty straightforward
process. Few times I got stuck when I tried to figure out &quot;how to do X in Rust&quot;
but that&#x27;s how you learn a new language I guess. Changing the technology helped
me to build things I wouldn&#x27;t be able to do with pure TS/JS or they would be too
slow.</p><p>The demo of my emulator can be found here <a href="https://vojty.github.io/feather-gb">https://vojty.github.io/feather-gb</a></p></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"var d=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(t,a,n)=\u003ea in t?d(t,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[a]=n,e=(t,a)=\u003e{for(var n in a||(a={}))o.call(a,n)\u0026\u0026l(t,n,a[n]);if(r)for(var n of r(a))s.call(a,n)\u0026\u0026l(t,n,a[n]);return t},h=(t,a)=\u003em(t,c(a));var p=(t,a)=\u003e{var n={};for(var i in t)o.call(t,i)\u0026\u0026a.indexOf(i)\u003c0\u0026\u0026(n[i]=t[i]);if(t!=null\u0026\u0026r)for(var i of r(t))a.indexOf(i)\u003c0\u0026\u0026s.call(t,i)\u0026\u0026(n[i]=t[i]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var i=n,{components:t}=i,a=p(i,[\"components\"]);return mdx(MDXLayout,h(e(e({},layoutProps),a),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Some of you might know that I've been on a journey to implement the GameBoy\nemulator.`),mdx(\"p\",null,\"I've decided to write down a few thoughts I've come into during the development.\"),mdx(\"h2\",e({},{id:\"the-origins\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#the-origins\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"The origins\"),mdx(\"p\",null,`I think I started this project in the summer of 2019. I always wanted to have a\nside project where I can polish things infinitely and try new technologies.\nActually, the original idea was to create a PS1 emulator, but I quickly realized\nthat emulating PS1 is `,mdx(\"strong\",{parentName:\"p\"},\"much harder\"),` than GB (and I didn't have any experience\nin emulating systems anyway).`),mdx(\"p\",null,`I didn't want to spend a lot of time learning a new programming language, so I\ndecided to use TypeScript which I had been using daily.`),mdx(\"p\",null,\"Timeline\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"2019 Fall - start\"),mdx(\"li\",{parentName:\"ul\"},\"2019 Winter - the first successful boot with scrolling Nintendo logo\"),mdx(\"li\",{parentName:\"ul\"},\"2020 March - working Dr. Mario and passing some integration tests\"),mdx(\"li\",{parentName:\"ul\"},\"2020 May - major refactor and made the CPU cycle-accurate\"),mdx(\"li\",{parentName:\"ul\"},\"2020 Summer - added support for general MBCs, many games was playable by then\"),mdx(\"li\",{parentName:\"ul\"},`2020 Fall - finally created scripts for automated testing, improved PPU's\naccuracy (added FIFO for background tiles and improved timing of some STAT\ninterrupts)`)),mdx(\"p\",null,`At the end of 2020, I started working on APU (audio processing unit). By then\nthe code was becoming slightly messy because I was discovering new things on the\nfly and had to refactor very often.`),mdx(\"h2\",e({},{id:\"transition-to-rust\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#transition-to-rust\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Transition to Rust\"),mdx(\"h3\",e({},{id:\"why\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#why\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Why\"),mdx(\"p\",null,`Fast forward to the beginning of 2021, I decided to completely rewrite the\nemulator to Rust. These were the major impulses:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`Rust can be compiled to WASM - I wanted to preserve the idea of Gameboy in the\nbrowser`),mdx(\"li\",{parentName:\"ul\"},`I was generally interested in Rust - I watched few Rust presentations, did\nsome exercises during the fall of 2020 and was ready to write something bigger`),mdx(\"li\",{parentName:\"ul\"},`I needed to build advanced debugging tools and visualize the internals in the\nreal-time. I was looking for something like\n`,mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/ocornut/imgui\"}),\"Dear ImGui\"),` for the browser, but I didn't\nfind anything quite usable (although there are JS bindings for Dear ImGui, the\nlibrary is missing an ES build \u0026 the dist version is polluted with SystemJS\nand the maintainer wants to keep it that way apparently...). Luckily I found\n`,mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/emilk/egui\"}),\"egui\")),mdx(\"li\",{parentName:\"ul\"},`Performance - During the development, the CPU usage in the browser went from\naround 20-30% to 80%`)),mdx(\"h3\",e({},{id:\"performance-issues\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#performance-issues\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Performance issues\"),mdx(\"p\",null,\"Let's do some basic calculation first:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`GameBoy's CPU runs at 4 194 304 Hz, the FPS is 59.7275 Hz\n-\u003e\n4 194 304 / 59.7275\\xA0=\\xA070 224 cycles per frame\n`)),mdx(\"p\",null,\"The alternative calculation:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`One scanline takes 456 cycles\nThere are 144 visible lines + 10 lines during V-blank\n-\u003e\n456 * (144 + 10) = 70 224 cycles per frame\n`)),mdx(\"p\",null,`Given the fact that one instruction takes 1-4 cycles to execute, you need to\nprocess more than `,mdx(\"strong\",{parentName:\"p\"},\"17 000 instructions per every frame\"),`. That's quite a lot so\nany \"not so optimal\" code in some critical execution path can affect your\nperformance greatly.`),mdx(\"p\",null,`This makes your debugging quite hard as well. You usually want to see what\nhappened during the code execution and print (almost) every step, but putting\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"console.log\"),` after every instruction is not really an option, because the\nbrowser will immediately freeze.`),mdx(\"p\",null,`Although it's definitely doable to write somehow performant GB emulator only in\nJavascript, I didn't care about the performance (we are used to the fact Chrome\neats all the RAM, right?) until it was kinda late and I didn't want to optimize\nmy messy code anyway.`),mdx(\"h3\",e({},{id:\"architecture-change\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#architecture-change\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Architecture change\"),mdx(\"p\",null,`I decided to split the project into multiple parts - the GB core and the\nfrontends. The simplified public API of the core is just 2 functions\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"run_frame()\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"get_screen_buffer()\"),`. The frontend can be anything - it just\nneeds to execute `,mdx(\"inlineCode\",{parentName:\"p\"},\"run_frame()\"),` and draw the screen buffer around 60 times per\nsecond. With this approach, I was able to develop the emulator with SDL2 on my\ncomputer and convert it to a web version using\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/rustwasm/wasm-bindgen\"}),\"wasm-bindgen\"),` afterward. Finally, the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"egui\"),` library (which can target WASM with WebGL) gave me the power to build\ncross-platform debugging tools. Suddenly I was able to write a simple and\nreal-time disassembler with no performance issues (the GUI web app is very\nperformant since it's WebGL).`),mdx(\"h3\",e({},{id:\"performance-concerns\"}),mdx(\"a\",e({parentName:\"h3\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#performance-concerns\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Performance concerns\"),mdx(\"p\",null,`I like the concept of immutability and it's also quite popular or even required\nwhen developing frontend with React. Usually, you just create or clone objects\nand arrays (although many times they are just shallow copies) as you need\nwithout any performance concerns.`),mdx(\"p\",null,`But writing an emulator this way is a terrible idea. One thing you want to avoid\nas much as possible is dynamic memory allocation. Almost everything in the\nGameBoy development has a fixed size so you can allocate the space upfront.`),mdx(\"p\",null,`Once, I hacked something very quickly and made a silly mistake. I used\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"std::collections::HashMap\"),` when I tried to store some information for every\nrendered pixel in the line like this\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"hashMap.insert(pixel_x, (color_number, priority))\"),`. When I checked the emulator\nin the browser after some time I noticed that the performance went somehow from\n~30% of CPU to almost 85%. Fortunately, I was able to trace this problem with\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/flamegraph-rs/flamegraph\"}),\"flamegraph\"),` very quickly. Those\nextra allocations more than doubled the overall performance. Using different\ndata structure fixed the problem.`),mdx(\"h2\",e({},{id:\"final-thoughts\"}),mdx(\"a\",e({parentName:\"h2\"},{\"aria-hidden\":\"true\",tabIndex:-1,href:\"#final-thoughts\"}),mdx(\"span\",e({parentName:\"a\"},{className:\"icon icon-link\"}))),\"Final thoughts\"),mdx(\"p\",null,`Sometimes it's better to start from scratch than trying to rewrite existing\ncode. The rewrite took me around two weeks and it was a pretty straightforward\nprocess. Few times I got stuck when I tried to figure out \"how to do X in Rust\"\nbut that's how you learn a new language I guess. Changing the technology helped\nme to build things I wouldn't be able to do with pure TS/JS or they would be too\nslow.`),mdx(\"p\",null,\"The demo of my emulator can be found here \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://vojty.github.io/feather-gb\"}),\"https://vojty.github.io/feather-gb\")))}MDXContent.isMDXComponent=!0;\n","scope":{"title":"GameBoy Emulation - From Typescript to Rust","description":"Few thoughts on switching from Typescript to Rust during the GameBoy emulator development","date":"2021-06-14"}},"frontMatter":{"title":"GameBoy Emulation - From Typescript to Rust","description":"Few thoughts on switching from Typescript to Rust during the GameBoy emulator development","date":"2021-06-14"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2021-06-24-gameboy-emulator-from-js-to-rust"},"buildId":"HWNRKxqCMGzF0_X3yiJQA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>